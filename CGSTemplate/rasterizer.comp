#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

// Output pixel buffer - matches SCREEN_ARRAY
layout(std430, binding = 0) buffer PixelBuffer {
    uint pixels[];
};

// Depth buffer
layout(std430, binding = 1) buffer DepthBuffer {
    float depths[];
};

// Triangle data: each triangle is 3 vertices with position (x,y,z,w) and color
struct Vertex {
    vec4 pos;      // screen space position (after projection)
    uint color;
    float u, v;    // texture coords
    float pad;
};

layout(std430, binding = 2) buffer TriangleBuffer {
    Vertex triangleVerts[];
};

// Line data: pairs of vertices
layout(std430, binding = 3) buffer LineBuffer {
    Vertex lineVerts[];
};

// Texture buffer (BGRA format)
layout(std430, binding = 4) buffer TextureBuffer {
    uint texturePixels[];
};

// Uniforms
uniform int screenWidth;
uniform int screenHeight;
uniform int numTriangles;
uniform int numLines;
uniform float time;
uniform int texWidth;
uniform int texHeight;
uniform int useTexture;  // 0 = use vertex color, 1 = use texture

// Convert screen coords to buffer index
int pixelIndex(int x, int y) {
    return y * screenWidth + x;
}

// Barycentric coordinate calculation
vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec2 v0 = c - a;
    vec2 v1 = b - a;
    vec2 v2 = p - a;
    
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1);
    float dot02 = dot(v0, v2);
    float dot11 = dot(v1, v1);
    float dot12 = dot(v1, v2);
    
    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    
    return vec3(1.0 - u - v, v, u);
}

// Check if point is inside triangle using barycentric coords
bool pointInTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec3 bary = barycentric(p, a, b, c);
    return bary.x >= 0.0 && bary.y >= 0.0 && bary.z >= 0.0;
}

// RGBA from uint (ARGB format)
vec4 unpackColor(uint c) {
    float a = float((c >> 24) & 0xFF) / 255.0;
    float r = float((c >> 16) & 0xFF) / 255.0;
    float g = float((c >> 8) & 0xFF) / 255.0;
    float b = float(c & 0xFF) / 255.0;
    return vec4(r, g, b, a);
}

uint packColor(vec4 c) {
    uint a = uint(clamp(c.a, 0.0, 1.0) * 255.0);
    uint r = uint(clamp(c.r, 0.0, 1.0) * 255.0);
    uint g = uint(clamp(c.g, 0.0, 1.0) * 255.0);
    uint b = uint(clamp(c.b, 0.0, 1.0) * 255.0);
    return (a << 24) | (r << 16) | (g << 8) | b;
}

// Sample texture (BGRA format) and convert to ARGB
vec4 sampleTexture(float u, float v) {
    // Clamp UV
    u = clamp(u, 0.0, 1.0);
    v = clamp(v, 0.0, 1.0);
    
    int x = int(u * float(texWidth - 1));
    int y = int(v * float(texHeight - 1));
    
    uint bgra = texturePixels[y * texWidth + x];
    
    // Convert BGRA to vec4 RGBA
    float bb = float((bgra >> 16) & 0xFF) / 255.0;
    float gg = float((bgra >> 8) & 0xFF) / 255.0;
    float rr = float(bgra & 0xFF) / 255.0;
    float aa = float((bgra >> 24) & 0xFF) / 255.0;
    
    return vec4(rr, gg, bb, aa);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= screenWidth || pixelCoord.y >= screenHeight)
        return;
    
    int idx = pixelIndex(pixelCoord.x, pixelCoord.y);
    vec2 p = vec2(pixelCoord);
    
    // Start with background (space black)
    uint finalColor = 0xFF000008;
    float finalDepth = 1000000.0;
    
    // Generate stars based on pixel position (deterministic)
    uint starSeed = uint(pixelCoord.x * 12345 + pixelCoord.y * 67890);
    starSeed = starSeed ^ (starSeed >> 16);
    starSeed = starSeed * 0x85ebca6b;
    starSeed = starSeed ^ (starSeed >> 13);
    if ((starSeed & 0x3FF) < 3) { // ~0.3% chance of star
        float brightness = float((starSeed >> 10) & 0xFF) / 255.0;
        brightness = 0.3 + brightness * 0.7;
        uint b = uint(brightness * 255.0);
        finalColor = 0xFF000000 | (b << 16) | (b << 8) | b;
    }
    
    // Process triangles
    for (int t = 0; t < numTriangles; t++) {
        int baseIdx = t * 3;
        Vertex v0 = triangleVerts[baseIdx + 0];
        Vertex v1 = triangleVerts[baseIdx + 1];
        Vertex v2 = triangleVerts[baseIdx + 2];
        
        vec2 a = v0.pos.xy;
        vec2 b = v1.pos.xy;
        vec2 c = v2.pos.xy;
        
        // Backface culling: check signed area (cross product of edges)
        vec2 edge1 = b - a;
        vec2 edge2 = c - a;
        float signedArea = edge1.x * edge2.y - edge1.y * edge2.x;
        if (signedArea >= 0.0) continue; // Back-facing triangle
        
        // Bounding box check
        vec2 minBB = min(min(a, b), c);
        vec2 maxBB = max(max(a, b), c);
        
        if (p.x < minBB.x || p.x > maxBB.x || p.y < minBB.y || p.y > maxBB.y)
            continue;
        
        // Barycentric test
        vec3 bary = barycentric(p, a, b, c);
        if (bary.x >= 0.0 && bary.y >= 0.0 && bary.z >= 0.0) {
            // Interpolate depth
            float z = bary.x * v0.pos.z + bary.y * v1.pos.z + bary.z * v2.pos.z;
            
            if (z < finalDepth) {
                finalDepth = z;
                
                vec4 pixelColor;
                
                // Check if this triangle is textured (per-triangle flag in pad field)
                bool triTextured = (v0.pad > 0.5);
                if (triTextured && texWidth > 0 && texHeight > 0) {
                    // Interpolate UVs
                    float interpU = bary.x * v0.u + bary.y * v1.u + bary.z * v2.u;
                    float interpV = bary.x * v0.v + bary.y * v1.v + bary.z * v2.v;
                    
                    // Sample texture
                    vec4 texColor = sampleTexture(interpU, interpV);
                    
                    // Apply lighting from vertex color (alpha channel stores lighting)
                    vec4 vertColor = unpackColor(v0.color);
                    float lighting = (vertColor.r + vertColor.g + vertColor.b) / 3.0;
                    if (lighting < 0.1) lighting = 1.0; // Default full bright if no lighting
                    
                    pixelColor = vec4(texColor.rgb * lighting, texColor.a);
                } else {
                    // Interpolate color
                    vec4 c0 = unpackColor(v0.color);
                    vec4 c1 = unpackColor(v1.color);
                    vec4 c2 = unpackColor(v2.color);
                    pixelColor = bary.x * c0 + bary.y * c1 + bary.z * c2;
                }
                
                finalColor = packColor(pixelColor);
            }
        }
    }
    
    // Process lines (simple Bresenham-like thickness)
    for (int l = 0; l < numLines; l++) {
        int baseIdx = l * 2;
        Vertex v0 = lineVerts[baseIdx + 0];
        Vertex v1 = lineVerts[baseIdx + 1];
        
        vec2 a = v0.pos.xy;
        vec2 b = v1.pos.xy;
        
        // Distance from point to line segment
        vec2 ab = b - a;
        float len2 = dot(ab, ab);
        if (len2 < 0.001) continue;
        
        float t = clamp(dot(p - a, ab) / len2, 0.0, 1.0);
        vec2 closest = a + t * ab;
        float dist = length(p - closest);
        
        // Line thickness of 1 pixel
        if (dist <= 0.7) {
            float z = mix(v0.pos.z, v1.pos.z, t);
            if (z < finalDepth) {
                finalDepth = z;
                finalColor = v0.color; // Use start vertex color
            }
        }
    }
    
    pixels[idx] = finalColor;
    depths[idx] = finalDepth;
}
